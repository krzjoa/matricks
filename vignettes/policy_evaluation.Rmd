---
title: "Use case: Iterative Policy Evaluation (Reinforcement Learning)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{matrices_and_vectors}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this vignette, we'll present a real-life use case, which shows how the `matricks` package makes the work with matrices easier. 

Let's try to implement an algorithm from the field of **Reinforcement Learning** called *iterative policy evaluation*. The environment we will work on is a simple **Grid World** game.

```{r setup}
library(matricks)
```

## Initializing environment

We initialize environment, using following functions from matrix package:
 
 * `m()`
 * `plot.matrix()`
 * `sv()`
 * `with_same_dims()`

```{r init.gid.world}
# Defining possible actions
# FALSE = unavailable field
actions <- m(T, T, T, F, T|
             T, T, F, T, T|
             F, T, T, T, T|
             T, T, T, T, T|
             F, F, T, T, T|
             F, T, T, T, F)
plot(actions)
# Defining rewards matrix with two terminal states
rewards <- with_same_dims(actions, 0)
rewards <- sv(rewards,
              c(4, 4) ~ 1.,
              c(5, 3) ~ -1)
plot(rewards)
rewards[rewards == 0] <- -0.1

```
## Setting fixed policy

**Policy** defines a set of moves we should perform, in order to achieve the best result in the game.
We start with a fixed policy values.

```{r fixed.policy}
# Symbols for moves
U <- "U"
D <- "D"
L <- "L"
R <- "R"

fixed.policy <- m(R , D , L , NA, D |
                  R , D , NA, D , L |
                  NA, R , D , D , D|
                  R , R , D , NA, D |
                  NA, NA, NA, U , L |
                  NA, R , U , L , NA)

as_idx <- function(x){
  n.row <- nrow(x)
  n.col <- ncol(x)

  result <- matrix(list(), nrow = n.row, ncol = n.col)

  for (i in 1:n.row){
    for (j in 1:n.col){
      coords <- c(i, j)
      
      if (is.na(at(x, coords)))
        next
      
      x.val <- x[i, j]

      switch (x.val,
        U = c(i - 1, j),
        D = c(i + 1, j),
        L = c(i, j - 1),
        R = c(i, j + 1),
      ) -> move.idx

      if (!is_idx_possible(x, move.idx))
        next

      result[i, j] <- list(move.idx)
    }
  }
  result
}

fixed.policy.idx <- as_idx(fixed.policy)
fixed.policy.idx

states <- matrix_idx(grid$actions, 
                     grid$actions)

```

## Policy evaluation function
```{r policy.evaluation}
# actions2 <- m(T, T, T, F|
#               T, F, T, F|
#               T, T, T, T)
# 
# rewards2 <- with_same_dims(actions2, 0)
# rewards2 <- sv(rewards2,
#               c(1, 4) ~ 1.,
#               c(2, 4) ~ -1)
# rewards2[rewards2 == 0] <- -0.1
# 
# fixed.policy <- m(R, R, R, NA |
#           U, NA, R, NA|
#           U, R, R, U)
# fixed.policy.idx <- as_idx(fixed.policy)
# 
# grid <- grid_world$new(actions = actions2,
#                        rewards = rewards2,
#                        start = c(1, 1))
# 
# states <- matrix_idx(grid$actions,
#                      grid$actions)

```


## Experiment
```{r experiment}
#evaluate_policy(grid, policy = fixed.policy.idx, states = states)
# Diagnoza: xle dziaÅ‚a funckja seq_matrix!!!
epsilon <- 1e-3
V <- with_same_dims(fixed.policy, 0)
gamma <- 0.9

while (TRUE) {
  biggest.change <- 0

  for (move in seq_matrix(fixed.policy.idx)) {
    s <- move[[1]] # Action, value at index s
    a <- move[[2]]
 
    old.v <- at(V, s)
      
    if(!at(actions, s))
      next
    
    if(is.null(a))
      next
      
    r <- at(rewards, a)
    at(V, s) <- r + gamma * at(V, a)
    biggest.change <- max(biggest.change, abs(old.v - at(V, s)))
  }
  
  print(biggest.change)
  
  if (biggest.change < epsilon){
    break
  }
    

}
V


```

