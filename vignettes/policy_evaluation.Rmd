---
title: "Use case: Iterative Policy Evaluation (Reinforcement Learning)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{matrices_and_vectors}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this vignette, we'll present a real-life use case, which shows how the `matricks` package makes the work with matrices easier. 

Let's try to implement an algorithm from the field of **Reinforcement Learning** called *iterative policy evaluation*. The environment we will work on is a simple **Grid World** game.

```{r setup}
library(matricks)
library(R6)
library(ggplot2)
```

## Implementing environment

```{r grid.world}
grid_world <- R6Class(
  classname = 'grid_world',
  
  public = list(
    
    # Default values
    width = 5,
    height = 5,
    i = 1,
    j = 1,
    rewards = NA, 
    actions = NA, # Possible actions
    
    initialize = function(width, height, start){
      self$width <- width
      self$height <- height
      self$i <- start[1]
      self$j <- start[2]
    },
    
    set = function(actions, rewards){
      self$rewards <- rewards
      self$actions <- actions  
    },
    
    set_state = function(s){
      self$i <- s[1]
      self$j <- s[2]
    },
    
    is_terminal = function(s){
      self$actions[s[1], s[2]]
    },
    
    game_over = function(){
      !self$actions[self$i, self$j]
    }
  )
)
```

## Initializing environment

We initialize environment, using following functions from matrix package:
 
 * `m()`
 * `plot.matrix()`
 * `sv()`
 * `with_same_dims()`

```{r init.gid.world}
# Creating grid_world instance
grid <- grid_world$new(width  = 6,
                       height = 5,
                       start  = c(1, 1))

# Defining possible actions
# FALSE = unavailable field
actions <- m(T, T, T, F, T|
             T, T, F, T, T|
             F, T, T, T, F|
             T, T, T, T, T|
             F, F, T, T, T|
             F, T, T, T, F)

plot(actions)
# Defining rewards matrix with two terminal states
rewards <- with_same_dims(actions, 0)
rewards <- sv(rewards,
              c(4, 4) ~ 1.,
              c(5, 3) ~ -1)

plot(rewards)

grid$set(actions = actions,
         rewards = rewards)

```
## Setting fixed policy

```{r fixed.policy}

  # plot(rewards) + 
  # geom_segment(arrow = TRUE)

```
